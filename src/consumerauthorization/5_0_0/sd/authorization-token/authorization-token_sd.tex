\documentclass[a4paper]{arrowhead}

\usepackage[yyyymmdd]{datetime}
\usepackage{etoolbox}
\usepackage[utf8]{inputenc}
\usepackage{multirow}

\renewcommand{\dateseparator}{-}

\setlength{\parskip}{1em}
\hyphenation{Er-ror-Res-pon-se}
\hyphenation{Au-thor-i-za-ti-on-Po-li-cy-List-Res-pon-se}

%% Special references
\newcommand{\fref}[1]{{\textcolor{ArrowheadBlue}{\hyperref[sec:functions:#1]{#1}}}}
\newcommand{\mref}[1]{{\textcolor{ArrowheadPurple}{\hyperref[sec:model:#1]{#1}}}}
\newcommand{\prref}[1]{{\textcolor{ArrowheadPurple}{\hyperref[sec:model:primitives:#1]{#1}}}}
\newcommand{\pdef}[1]{{\textcolor{ArrowheadGrey}{#1\label{sec:model:primitives:#1}\label{sec:model:primitives:#1s}\label{sec:model:primitives:#1es}}}}
\newcommand{\pref}[1]{{\textcolor{ArrowheadGrey}{\hyperref[sec:model:primitives:#1]{#1}}}}

\newrobustcmd\fsubsection[5]{
  \addtocounter{subsection}{1}
  \addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}operation \textcolor{ArrowheadBlue}{#1}}
  \renewcommand*{\do}[1]{\rref{##1},\ }
  \subsection*{
    \thesubsection\quad
    operation
    \textcolor{ArrowheadBlue}{#1}
    (\notblank{#2}{\mref{#2}}{})
    \notblank{#3}{: \mref{#3}}{}
    \notblank{#4}{: \prref{#4}}{}
    \notblank{#5}{/ \mref{#5}}{}
  }
  \label{sec:functions:#1}
}
\newrobustcmd\msubsection[2]{
  \addtocounter{subsection}{1}
  \addcontentsline{toc}{subsection}{\protect\numberline{\thesubsection}#1 \textcolor{ArrowheadPurple}{#2}}
  \subsection*{\thesubsection\quad#1 \textcolor{ArrowheadPurple}{#2}}
  \label{sec:model:#2} \label{sec:model:#2s} \label{sec:model:#2es}
}
\newrobustcmd\msubsubsection[3]{
  \addtocounter{subsubsection}{1}
  \addcontentsline{toc}{subsubsection}{\protect\numberline{\thesubsubsection}#1 \textcolor{ArrowheadPurple}{#2}}
  \subsubsection*{\thesubsubsection\quad#1 \textcolor{ArrowheadPurple}{#2}}
  \label{sec:model:#2} \label{sec:model:#2s}
}
%%

\begin{document}

%% Arrowhead Document Properties
\ArrowheadTitle{authorizationToken} % XXX = ServiceName 
\ArrowheadServiceID{authorizationToken} % ID name of service
\ArrowheadType{Service Description}
\ArrowheadTypeShort{SD}
\ArrowheadVersion{5.0.0} % Arrowhead version X.Y.Z, e..g. 4.4.1
\ArrowheadDate{\today}
\ArrowheadAuthor{Tamás Bordi} % Corresponding author e.g. Jerker Delsing
\ArrowheadStatus{DRAFT} % e..g. RELEASE, RELEASE CONDIDATE, PROTOTYPE
\ArrowheadContact{tbordi@aitia.ai} % Email of corresponding author
\ArrowheadFooter{\href{www.arrowhead.eu}{www.arrowhead.eu}}
\ArrowheadSetup
%%

%% Front Page
\begin{center}
  \vspace*{1cm}
  \huge{\arrowtitle}

  \vspace*{0.2cm}
  \LARGE{\arrowtype}
  \vspace*{1cm}

  %\Large{Service ID: \textit{"\arrowid"}}
  \vspace*{\fill}

  % Front Page Image
  %\includegraphics{figures/TODO}

  \vspace*{1cm}
  \vspace*{\fill}

  % Front Page Abstract
  \begin{abstract}
    This document provides service description for the \textbf{authorizationToken} service. 
  \end{abstract}

  \vspace*{1cm}

%   \scriptsize
%   \begin{tabularx}{\textwidth}{l X}
%     \raisebox{-0.5\height}{\includegraphics[width=2cm]{figures/artemis_logo}} & {ARTEMIS Innovation Pilot Project: Arrowhead\newline
%     THEME [SP1-JTI-ARTEMIS-2012-AIPP4 SP1-JTI-ARTEMIS-2012-AIPP6]\newline
%     [Production and Energy System Automation Intelligent-Built environment and urban infrastructure for sustainable and friendly cities]}
%   \end{tabularx}
%   \vspace*{-0.2cm}
 \end{center}

\newpage
%%

%% Table of Contents
\tableofcontents
\newpage
%%

\section{Overview}
\label{sec:overview}
This document describes the \textbf{authorizationToken} service, which enables the verification of service consumption permissions on the provider system side, and the application of session-based service consumption control between the consumer and provider systems. An example of this interaction is when a consumer system with proper permissions obtains an expiring token of the appropriate type, which it then attaches to its service consumption attempt. The provider system verifies the received token and performs the service operation only if the token has not expired and is valid for the actual service operation. Additionally, provider systems can choose to have the tokens generated for its services encrypted.

The \textbf{authorizationToken} service contains the following operations:

\begin{itemize}
    \item \textit{generate} verifies the requester's permissions and produces a token of defined type for the targeted service consumption;
    \item \textit{verify} checks whether a given token is valid or not, is associated with the requester or not and it provides the belonged token details;
    \item \textit{get-public-key} provides the public key of the implementing system if any (necessary for the verification of some token types);
    \item \textit{register-encryption-key} stores an encryption key that can be used to encrypt the raw tokens generated for any service of the requester system.
    \item \textit{unregister-encryption-key} removes the encryption key belonged to the requester system.
\end{itemize}

The rest of this document is organized as follows.
In Section \ref{sec:functions}, we describe the abstract message operations provided by the service.
In Section \ref{sec:model}, we end the document by presenting the data types used by the mentioned operations.

\subsection{How This Service Is Meant to Be Used}

\subsubsection{Consumer system side} 

After the service discovery, when consumer system has all the access details for a specific service instance  - which requires token level security - the consumer should call the \textit{generate} operation with the exact token type - defined in the given access details - in order to obtain a service authorization token. 

When it comes to the service consumption attempt, the received token should be attached to the connection request. 

\subsubsection{Provider system side}

When a provider system requires token level security for its provided service, and receives a connection request, then it should make sure that a token is provided by the requester (consumer) according to its service interface specification. If there is no token, the connection request should be rejected. If token has been received, the provider system should verify whether it is not expired yet, the token belongs to itself and is valid to the service operation that is targeted by the requester. However, the exact way of token verification could differ according to the token type.

\textbf{Simple token}s are not holding any kind of information. These can only be verified by consulting the system implementing the authorizationToken service. The \textit{verify} operation should be called by the provider.

\textbf{Self-contained token}s are holding all the necessary information for the provider system to verify it independently. However, the way of accessing to the token payload could differ according to the exact self-contained token variant. Since these kind of tokens are holding sensitive information, there is an option to provide the tokens for the consumers encrypted using a secret shared by the provider with the token creator entity (the system implementing the authorizationToken service). For registering a shared secret, the \textit{register-encryption-key} operation can be called. Some self-contained token enables the verification of its creator entity. In order to do such a verification, a public key from the creator entity will be required. In order to obtain a public key the \textit{get-public-key} operation can be called.

\subsection{Important Delimitations}
\label{sec:delimitations}

The requester has to identify itself to use any of the operations.

\subsection{Access policy}
\label{sec:accesspolicy}

Available for anyone within the local cloud without any authorization rights.

\newpage

\section{Service Operations}
\label{sec:functions}

This section describes the abstract signatures of each operations of the service. In particular, each subsection names an operation, an input type and one or two output types (unsuccessful operations can return different structure), in that order.
The input type is named inside parentheses, while the output type is preceded by a colon. If the operation has two output types, they are separated by a slash.
Input and output types are only denoted when accepted or returned, respectively, by the operation in question. All abstract data types named in this section are defined in Section 3.

\phantomsection
\fsubsection{generate}{AuthorizationTokenGenerationRequest}{AuthorizationTokenGenerationResponse}{}{ErrorResponse}

Operation \textit{generate} verifies the requester’s permissions to the targeted service/service-operation instance and produces an expiring token of defined type associated with the requester (consumer) system, the service provider system and with the service itself. The operation returns the generated token and the belonged details. The generated token can be a simple token or a self-contained token.

\textbf{Simple token}s are not holding any kind of information. These can only be verified by consulting the system implementing the authorizationToken service. See the \textit{verify} operation.

\textbf{Self-contained token}s are holding all the necessary information for the provider system to verify it independently. If an encryption key associated with the targeted service provider system is stored, the token will be provided encrypted with that key. See the \textit{register-encryption-key} operation.

\fsubsection{verify}{AuthorizationTokenVerifyRequest}{AuthorizationTokenVerifyResponse}{}{ErrorResponse}

Operation \textit{verify} checks whether a given simple type token is valid or not, is associated with the requester (provider) system or not and it returns the belonged token details. If the token is verified, then based on the returned token details, the provider system can ensure that the token is valid to the targeted service-operation or not.

Verifying self-contained type of tokens with this operation is not possible.

\fsubsection{public-key}{Identity}{PublicKeyResponse}{}{ErrorResponse}

Operation \textit{public-key} returns the \pref{PublicKey} of the implementing system, if available. Having a \pref{PublicKey} is only possible if the system supports an asymmetric encryption solution. Some self-contained token type also support asymmetric encryption, allowing the requester (provider) system to verify whether the token was created by the same system that the \pref{PublicKey} belongs to." 

\fsubsection{register-encryption-key}{AuthorizationEncryptionKeyRegistrationRequest}{AuthorizationEncryptionKeyRegistrationResponse}{}{ErrorResponse}

Operation \textit{register-encryption-key} saves and stores a \pref{String} key and an encryption algorithm identifier, that is provided by and belongs to the requester (provider) system. Any time when a self-contained token is generated that is associated with the same provider, the token will be provided to the consumer system encrypted, using the specified key and encryption algorithm. If the given algorithm is using any addition (beside the encryption key) for the encryption process, such as salt or initialization vector for example, then this addition is returned to the requester (provider) system. Once a consumer systems sends a service request with an encrypted self-signed token, the provider system can decrypt it with the encryption key defined by itslef and with the addition received as the response of this operation if any.

\fsubsection{unregister-encryption-key}{Identity}{OperationStatus}{}{ErrorResponse}

Operation \textit{unregister-encryption-key} removes the stored encryption key and algorithm identifier associated with the requester (provider) system. The result of this operation is that further tokens generated to any of the provider's service, won't be encrypted. 

\clearpage

\section{Information Model}
\label{sec:model}

Here, all data objects that can be part of the \textbf{authorizationToken} service are listed and must be respected by the hosting system.
Note that each subsection, which describes one type of object, begins with the \textit{struct} keyword, which is used to denote a collection of named fields, each with its own data type.
As a complement to the explicitly defined types in this section, there is also a list of implicit primitive types in Section \ref{sec:model:primitives}, which are used to represent things like hashes and identifiers.

\phantomsection
\msubsection{struct}{AuthorizationTokenGenerationRequest}

\begin{table}[ht!]
\begin{tabularx}{\textwidth}{| p{3cm} | p{4.5cm} | p{2cm} | X |} \hline
\rowcolor{gray!33} Field & Type & Mandatory & Description \\ \hline
authentication & \hyperref[sec:model:Identity]{Identity} & yes & The requester of the operation. \\ \hline
tokenVariant & \pref{AccessTokenVariant} & yes & Exact type of token technology. \\ \hline
provider & \pref{SystemName} & yes & Name of the targeted provider system. \\ \hline
targetType & \pref{AccessTargetType} & yes & Type of the targeted resource. \\ \hline
target & \pref{ServiceName} / \pref{EventTypeName} & yes & Target of the token. \\ \hline
scope & \hyperref[sec:model:AccessTokenScope]{AccessTokenScope} & no & Scope of the token. Only matters when the target is a service definition. \\ \hline
\end{tabularx}
\end{table}

\msubsection{struct}{Identity}

An \pref{Object} which describes the identity of a system. It also contains whether the identified system has higher level administrative rights.

\msubsection{struct}{AccessTokenScope}

A \pref{String} which specifies the scope of the token. It can be \pref{ServiceOperationName} if the token target is a \pref{ServiceName} and the token is limited to one particular service-operation or it can be empty if the token is not limited or the target is an \pref{EventTypeName}. 

\msubsection{struct}{AuthorizationTokenVerifyRequest}

\begin{table}[ht!]
\begin{tabularx}{\textwidth}{| p{3cm} | p{4.5cm} | p{2cm} | X |} \hline
\rowcolor{gray!33} Field & Type & Mandatory & Description \\ \hline
authentication & \hyperref[sec:model:Identity]{Identity} & yes & The requester of the operation. \\ \hline
token & \pref{AccessToken} & yes & The token requested to being verified. \\ \hline
\end{tabularx}
\end{table}

\clearpage

\msubsection{struct}{AuthorizationEncryptionKeyRegistrationRequest}

\begin{table}[ht!]
\begin{tabularx}{\textwidth}{| p{3cm} | p{4.5cm} | p{2cm} | X |} \hline
\rowcolor{gray!33} Field & Type & Mandatory & Description \\ \hline
authentication & \hyperref[sec:model:Identity]{Identity} & yes & The requester of the operation. \\ \hline
key & \pref{String} & yes & A secret key. \\ \hline
algorithm & \pref{EncryptionAlgorithmName} & yes & A specific algorithm. \\ \hline
\end{tabularx}
\end{table}

\msubsection{struct}{AuthorizationTokenGenerationResponse}

\begin{table}[ht!]
\begin{tabularx}{\textwidth}{| p{4.25cm} | p{4.5cm} | X |} \hline
\rowcolor{gray!33} Field & Type & Description \\ \hline
status & \pref{OperationStatus} & Status of the operation. \\ \hline
tokenType & \pref{AccessTokenType} & Type of token technology group. \\ \hline
targetType & \pref{AccessTargetType} & Type of the targeted resource. \\ \hline
token & \pref{AccessToken} & The token itself. \\ \hline
usageLimit & \pref{Number} & Maximum number of token usage, if any. \\ \hline
expiresAt & \pref{DateTime} & Token is valid until this timestamp, if any. \\ \hline
\end{tabularx}
\end{table}

\msubsection{struct}{ErrorResponse}

\begin{table}[ht!]
\begin{tabularx}{\textwidth}{| p{4.25cm} | p{3.5cm} | X |} \hline
\rowcolor{gray!33} Field & Type      & Description \\ \hline
status & \pref{OperationStatus} & Status of the operation. \\ \hline
errorMessage & \pref{String} & Description of the error. \\ \hline
errorCode &\pref{Number}  & Numerical code of the error. \\ \hline
type & \pref{ErrorType} & Type of the error. \\ \hline
origin & \pref{String} & Origin of the error. \\ \hline
\end{tabularx}
\end{table}

\msubsection{struct}{PublicKeyResponse}

\begin{table}[ht!]
\begin{tabularx}{\textwidth}{| p{4.25cm} | p{4.5cm} | X |} \hline
\rowcolor{gray!33} Field & Type & Description \\ \hline
status & \pref{OperationStatus} & Status of the operation. \\ \hline
publicKey & \pref{PublicKey} & The public key. \\ \hline
\end{tabularx}
\end{table}

\clearpage

\msubsection{struct}{AuthorizationEncryptionKeyRegistrationResponse}

\begin{table}[ht!]
\begin{tabularx}{\textwidth}{| p{4.25cm} | p{4.5cm} | X |} \hline
\rowcolor{gray!33} Field & Type & Description \\ \hline
status & \pref{OperationStatus} & Status of the operation. \\ \hline
addition & \pref{String} & Any string addition what the defined algorithm is using, if any. \\ \hline
\end{tabularx}
\end{table}

\msubsection{struct}{AuthorizationTokenVerifyResponse}

\begin{table}[ht!]
\begin{tabularx}{\textwidth}{| p{4.25cm} | p{4.5cm} | X |} \hline
\rowcolor{gray!33} Field & Type & Description \\ \hline
status & \pref{OperationStatus} & Status of the operation. \\ \hline
verified & \pref{Boolean} & The result of the verification. \\ \hline
consumerCloud & \pref{CloudIdentifier} & The cloud of the consumer the token is associated with. \\ \hline
consumer & \pref{SystemName} & Name of the consumer the token is associated with. \\ \hline
targetType & \pref{AccessTargetType} & Type of the targeted resource the token is associated with. \\ \hline
target & \pref{ServiceName} / \pref{EventTypeName} & The target the token is associated with. \\ \hline
scope & \hyperref[sec:model:AccessTokenScope]{AccessTokenScope} & Scope of the token. \\ \hline
\end{tabularx}
\end{table}

\newpage

\subsection{Primitives}
\label{sec:model:primitives}

Types and structures mentioned throughout this document that are assumed to be available to implementations of this service.
The concrete interpretations of each of these types and structures must be provided by any IDD document claiming to implement this service.


\begin{table}[ht!]
\begin{tabularx}{\textwidth}{| p{5cm} | X |} \hline
\rowcolor{gray!33} Type & Description \\ \hline
\pdef{AccessTargetType} & A string reference that specifies the type of the targeted resource. \\ \hline
\pdef{AccessToken} & A random and possibly unique string of characters that is issued for a beneficiary system and is associated at least with a target system, a scope and is expiring.\\ \hline
\pdef{AccessTokenType} & A string reference that specifies a token technology group.\\ \hline
\pdef{AccessTokenVariant} & A string reference that specifies an exact token technology variant.\\ \hline
\pdef{Boolean}          & One out of true or false. \\ \hline
\pdef{CloudIdentifier} & A composite string identifier that is intended to be both human and machine-readable. It consists of the cloud name and the organization name that managing the cloud. Each part must follow the PascalCase naming convention. \\ \hline
\pdef{DateTime}         & Pinpoints a specific moment in time. \\ \hline
\pdef{ErrorType}        & Any suitable type chosen by the implementor of service. \\ \hline
\pdef{EncryptionAlgorithmName} & A string identifier that belongs to an encryption algorithm. \\ \hline
\pdef{EventTypeName}      & A string identifier that is intended to be both human and machine-readable. Must follow camelCase naming convention. \\ \hline
\pdef{Object}           & Set of primitives and possible further objects. \\ \hline
\pdef{OperationStatus}  & Logical, textual or numerical value that indicates whether an operation is a success or a failure. Multiple values can be used for success and error cases to give additional information about the nature of the result. \\ \hline
\pdef{PublicKey} & TODO \\ \hline
\pdef{ServiceName}      & A string identifier that is intended to be both human and machine-readable. Must follow camelCase naming convention. \\ \hline
\pdef{ServiceOperationName} & A string identifier that is intended to be both human and machine-readable. Must follow kebab-case naming convention. \\ \hline
\pdef{String}           & A chain of characters. \\ \hline
\pdef{SystemName}       & A string identifier that is intended to be both human and machine-readable. Must follow PascalCase naming convention. \\ \hline
\end{tabularx}
\end{table}

\newpage

\bibliographystyle{IEEEtran}
\bibliography{bibliography}

\newpage

\section{Revision History}
\subsection{Amendments}

\noindent\begin{tabularx}{\textwidth}{| p{1cm} | p{3cm} | p{2cm} | X | p{4cm} |} \hline
\rowcolor{gray!33} No. & Date & Version & Subject of Amendments & Author \\ \hline

1 & YYYY-MM-DD & \arrowversion & & Xxx Yyy \\ \hline
\end{tabularx}

\subsection{Quality Assurance}

\noindent\begin{tabularx}{\textwidth}{| p{1cm} | p{3cm} | p{2cm} | X |} \hline
\rowcolor{gray!33} No. & Date & Version & Approved by \\ \hline

1 & YYYY-MM-DD & \arrowversion  &  \\ \hline

\end{tabularx}

\end{document}